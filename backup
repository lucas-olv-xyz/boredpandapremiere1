function randomizeRowsByColors1() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();

  // Lista das c√©lulas que cont√™m as cores de interesse
  const colorCells = [
    "A2",
    "A3",
    "A4",
    "A5",
    "A6",
    "A7",
    "A8",
    "A9",
    "A10",
    "A11",
  ]; // Adicione mais c√©lulas conforme necess√°rio

  colorCells.forEach((cell) => {
    randomizeRowsByColor(sheet, sheet.getRange(cell).getBackground());
  });
}

function randomizeRowsByColor(sheet, targetColor) {
  // Define o intervalo para procurar as c√©lulas com a mesma cor (abaixo da linha 11)
  const rangeToCheck = sheet.getRange("A12:A");
  const backgrounds = rangeToCheck.getBackgrounds();

  // Coleta as linhas que t√™m a mesma cor de fundo que a c√©lula fornecida
  const rowsToRandomize = [];
  for (let i = 0; i < backgrounds.length; i++) {
    if (backgrounds[i][0] === targetColor) {
      rowsToRandomize.push(i + 12); // +12 para corresponder √† linha real na planilha
    }
  }

  // Se n√£o houver linhas para randomizar, saia da fun√ß√£o
  if (rowsToRandomize.length === 0) return;

  // Seleciona o intervalo das linhas para randomizar (A at√© H)
  const rangesToRandomize = rowsToRandomize.map((row) => `A${row}:H${row}`);
  const rangeList = sheet.getRangeList(rangesToRandomize);

  // Aplica randomize para as linhas selecionadas
  const values = rangeList.getRanges().map((range) => range.getValues());

  // Embaralha as linhas selecionadas
  const shuffledValues = shuffleArray(values);

  // Escreve os valores embaralhados de volta
  shuffledValues.forEach((rowValues, index) => {
    sheet
      .getRange(rowsToRandomize[index], 1, 1, rowValues[0].length)
      .setValues(rowValues);
  });
}

// Fun√ß√£o auxiliar para embaralhar um array
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

--------------------------

function concatenateValuesByColor() {
    var sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
    
    // Define range
    var rangeB = sheet.getRange("B12:B"); // Column B starting from B12
    var valuesB = rangeB.getValues();
  
    var idList = [];
  
    // Extract and process the IDs from Column B
    for (var i = 0; i < valuesB.length; i++) {
      var cellValueB = valuesB[i][0];
      if (cellValueB) { // Skip empty cells
        var valueBeforeSpace = cellValueB.split(' ')[0]; // Get value before first space
        idList.push(valueBeforeSpace);
      }
    }
  
    // Concatenate IDs into a single string separated by commas
    var concatenatedIDs = idList.join(", ");
  
    // Output the concatenated string to cell B10
    sheet.getRange("B10").setValue(concatenatedIDs);
  }
  
  function onEdit(e) {
    var range = e.range;
  
    if (range.getColumn() === 2 && range.getRow() >= 12) { // Edit in column B starting from row 12
      concatenateValuesByColor(); // Run the concatenation function on any edit in column B
      var sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
      sheet.getRange("B10").setBackground("#d4f8d4"); // Set background to light green for B10 after concatenation
    }
  }
  
  
  function triggerConcatenation() {
    concatenateValuesByColor(); // Call the main function
  }
  
  function exportToGoogleDoc() {
    var sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
    var concatenatedIDs = sheet.getRange("B10").getValue();
    
    if (concatenatedIDs && concatenatedIDs !== "N/A") { // Only proceed if there's a valid result in B10
      var doc = DocumentApp.create("Exported Data");
      var body = doc.getBody();
      body.appendParagraph(concatenatedIDs);
      
      var docUrl = doc.getUrl();
      Logger.log("Google Doc created with URL: " + docUrl);
      
      // Display the document URL as a clickable link in a dialog
      var htmlOutput = HtmlService.createHtmlOutput('<a href="' + docUrl + '" target="_blank">Open the Google Doc</a>');
      SpreadsheetApp.getUi().showModalDialog(htmlOutput, 'Document Created');
    } else {
      SpreadsheetApp.getUi().alert('B10 is either empty or contains an invalid value.');
    }
  }
  
  function findAndOutputSpreadsheetURL() {
    var sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
    var titleRow = 2; // Inicializa a linha para adicionar os t√≠tulos come√ßando de A2
    
    // Limpa as c√©lulas da coluna A (A2 at√© A8) antes de adicionar novos t√≠tulos
    sheet.getRange('A2:A8').clearContent();
  
    // Loop through rows 2 to 8
    for (var i = 2; i <= 8; i++) {
      // Get the value from column E of the current row
      var searchTerm = sheet.getRange('E' + i).getValue();
      
      // Check if the search term is not empty
      if (searchTerm) {
        // Create the search query for Google Drive
        var query = 'title contains "' + searchTerm + '" and mimeType = "application/vnd.google-apps.spreadsheet"';
        
        // Search for files in Google Drive
        var files = DriveApp.searchFiles(query);
        
        // Initialize the file URL and file name
        var fileUrl = '';
        var fileId = '';
        var fileName = '';
        
        // If files are found, get the URL, ID, and name of the first one
        if (files.hasNext()) {
          var file = files.next();
          fileUrl = file.getUrl();
          fileId = file.getId();
          fileName = file.getName();
          
          // Adiciona o nome do arquivo na coluna A (A2 at√© A8)
          if (titleRow <= 8) {
            sheet.getRange('A' + titleRow).setValue(fileName);
            titleRow++;
          }
        } else {
          fileName = 'No spreadsheet found with the name: ' + searchTerm;
        }
        
        // Output the result as a smart chip to column F of the current row
        if (fileId) {
          // Use setRichTextValue to insert the file URL and name
          var cell = sheet.getRange('F' + i);
          cell.setValue(fileName); // Set the file name first
          cell.setRichTextValue(SpreadsheetApp.newRichTextValue()
            .setText(fileName)
            .setLinkUrl(fileUrl)
            .build());
        } else {
          sheet.getRange('F' + i).setValue(fileName);
        }
      }
    }
  }
  
  function colorCellsByID() {
    var sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
    
    // Get the IDs and their corresponding colors from column A (A2 to A7)
    var rangeA = sheet.getRange('A2:A7');
    var valuesA = rangeA.getValues();
    var backgroundsA = rangeA.getBackgrounds();
    
    var idColorMap = {};
  
    for (var i = 0; i < valuesA.length; i++) {
      var cellValueA = valuesA[i][0];
      if (cellValueA) { // Only process non-empty cells
        var id = cellValueA.split(' ')[0]; // Get value before the first space
        var color = backgroundsA[i][0];
        idColorMap[id] = color;
      }
    }
  
    // Get the range of column B starting from B12
    var rangeB = sheet.getRange("B12:B");
    var valuesB = rangeB.getValues();
    
    // Loop through column B and color the entire row from column A to column I according to the ID color map
    for (var i = 0; i < valuesB.length; i++) {
      var cellValueB = valuesB[i][0];
      if (cellValueB) {
        for (var id in idColorMap) {
          if (cellValueB.includes(id)) {
            sheet.getRange("A" + (i + 12) + ":I" + (i + 12)).setBackground(idColorMap[id]);
            break;
          }
        }
      }
    }
  }
  
  // Test function to ensure it's working
  function testColorCellsByID() {
    colorCellsByID();
  }
  
  
  //importar os dados das planilhas..
  function copyAllDataFromLinks1() {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
    const range = sheet.getRange("F2:F8"); // Intervalo dos links
    const cells = range.getRichTextValues(); // Obt√©m os valores ricos das c√©lulas
    
    cells.forEach((cell, index) => {
      const link = cell[0].getLinkUrl(); // Obt√©m o link
      
      if (link) {
        Logger.log("Link encontrado na c√©lula F" + (index + 2) + ": " + link);
        
        // Extrai o ID da planilha a partir do link
        const spreadsheetId = extractSpreadsheetId(link); 
        
        if (spreadsheetId) {
          Logger.log("ID da planilha encontrado: " + spreadsheetId);
          
          // Abre a planilha de destino
          const targetSpreadsheet = SpreadsheetApp.openById(spreadsheetId);
          
          // Acessa a aba "25%"
          const targetSheet = targetSpreadsheet.getSheetByName("25%");
          
          if (targetSheet) {
            const lastRow = targetSheet.getLastRow(); // Captura a √∫ltima linha preenchida
            const data = targetSheet.getRange(3, 1, lastRow - 2, 9).getValues(); // L√™ da coluna A (1) at√© a coluna I (9)
  
            Logger.log("Dados capturados: " + JSON.stringify(data));
            // Converte a coluna de dura√ß√£o para texto expl√≠cito (supondo que esteja na coluna H)
            data.forEach(row => {
              row[7] = formatDurationAsString(row[7]); // Coluna H
            });
  
            // Encontra a √∫ltima linha preenchida na planilha atual
            const lastFilledRow = sheet.getLastRow();
            
            // Define o intervalo de destino para colar os dados
            const destinationRange = sheet.getRange(lastFilledRow + 1, 1, data.length, data[0].length);
            destinationRange.setValues(data);
          } else {
            Logger.log("A aba '25%' n√£o foi encontrada para o link na c√©lula F" + (index + 2));
          }
        } else {
          Logger.log("ID da planilha n√£o encontrado no link na c√©lula F" + (index + 2));
        }
      } else {
        Logger.log("Nenhum link encontrado na c√©lula F" + (index + 2));
      }
    });
  }
  
  // Fun√ß√£o para extrair o ID da planilha do link
  function extractSpreadsheetId(url) {
    const matches = url.match(/[-\w]{25,}/);
    return matches ? matches[0] : null;
  }
  
  // Fun√ß√£o para converter a dura√ß√£o para uma string formatada
  function formatDurationAsString(duration) {
    if (duration instanceof Date) {
      const hours = ('0' + duration.getUTCHours()).slice(-2);
      const minutes = ('0' + duration.getUTCMinutes()).slice(-2);
      const seconds = ('0' + duration.getUTCSeconds()).slice(-2);
      return `${hours}:${minutes}:${seconds}.000`;
    }
    return duration;
  }
  "C:/Users/theel/Videos/premiere_test/watermark/watermark.png"

  function importFilesFromTXT() {
    try {
      var txtPath =
        "C:/Program Files (x86)/Common Files/Adobe/CEP/extensions/boredpanda/arquivos.txt"; // Caminho fixo do TXT
      var txtFile = new File(txtPath);
  
      if (!txtFile.exists) {
        return "‚ùå O arquivo TXT n√£o foi encontrado: " + txtPath;
      }
  
      txtFile.open("r"); // Abre o arquivo no modo de leitura
      var filePaths = [];
  
      while (!txtFile.eof) {
        var line = txtFile.readln(); // L√™ uma linha do TXT
  
        if (line && line.length > 0) {
          // Verifica se a linha n√£o est√° vazia
          filePaths.push(line); // Adiciona ao array
        }
      }
      txtFile.close(); // Fecha o arquivo ap√≥s a leitura
  
      if (filePaths.length === 0) {
        return "‚ö†Ô∏è O TXT est√° vazio ou n√£o cont√©m caminhos v√°lidos.";
      }
  
      var project = app.project;
      var importedFiles = 0;
  
      for (var i = 0; i < filePaths.length; i++) {
        var file = new File(filePaths[i]);
        if (file.exists) {
          try {
            project.importFiles([file.fsName], true, project.rootItem, false);
            importedFiles++;
          } catch (e) {
            return "Erro ao importar: " + file.fsName;
          }
        } else {
          return "‚ùå Arquivo n√£o encontrado: " + filePaths[i];
        }
      }
  
      return importedFiles + " arquivos importados diretamente para o projeto.";
    } catch (e) {
      return "Erro inesperado: " + e.toString();
    }
  }
  
  function addFilesToTimeline() {
    try {
      var txtPath =
        "C:/Program Files (x86)/Common Files/Adobe/CEP/extensions/boredpanda/arquivos.txt";
      var txtFile = new File(txtPath);
  
      if (!txtFile.exists) {
        return "‚ùå O arquivo TXT n√£o foi encontrado: " + txtPath;
      }
  
      txtFile.open("r"); // Abre o arquivo no modo de leitura
      var filePaths = [];
  
      while (!txtFile.eof) {
        var line = txtFile.readln();
        if (line && line.length > 0) {
          filePaths.push(line); // Adiciona os caminhos ao array
        }
      }
      txtFile.close();
  
      if (filePaths.length === 0) {
        return "‚ö†Ô∏è O TXT est√° vazio ou n√£o cont√©m caminhos v√°lidos.";
      }
  
      filePaths.reverse(); // üî• INVERTE A ORDEM PARA GARANTIR QUE SEJA LIDO DO TOPO PARA BAIXO üî•
  
      var project = app.project;
      var sequence = project.activeSequence;
  
      if (!sequence) {
        return "‚ùå Nenhuma sequ√™ncia ativa encontrada. Crie uma sequ√™ncia primeiro.";
      }
  
      var videoTrack = sequence.videoTracks[0]; // Obt√©m a trilha de v√≠deo
      if (!videoTrack) {
        return "‚ùå Nenhuma trilha de v√≠deo dispon√≠vel.";
      }
  
      var currentTime = sequence.getPlayerPosition(); // Obt√©m a posi√ß√£o atual na timeline
  
      for (var i = 0; i < filePaths.length; i++) {
        var clipName = filePaths[i].split("/").pop().split("\\").pop(); // Obt√©m apenas o nome do arquivo
        var item = findItemInProject(clipName);
  
        if (item) {
          try {
            videoTrack.insertClip(item, currentTime); // Adiciona o clipe √† timeline na ordem certa
            currentTime += item.getOutPoint().seconds; // Move o cursor para depois do clipe
          } catch (e) {
            return "‚ùå Erro ao adicionar " + clipName + " √† timeline.";
          }
        } else {
          return "‚ùå Arquivo n√£o encontrado no projeto: " + clipName;
        }
      }
  
      return "‚úÖ Arquivos adicionados √† timeline na ordem correta.";
    } catch (e) {
      return "Erro inesperado: " + e.toString();
    }
  }
  
  // Fun√ß√£o auxiliar para encontrar um arquivo pelo nome no projeto
  function findItemInProject(name) {
    var rootItem = app.project.rootItem;
    var numItems = rootItem.children.numItems;
    var matchedItems = [];
  
    for (var i = 0; i < numItems; i++) {
      var item = rootItem.children[i];
      if (item && item.name === name) {
        matchedItems.push(item); // Armazena todos os itens com o mesmo nome
      }
    }
  
    if (matchedItems.length > 0) {
      return matchedItems[0]; // Retorna o primeiro encontrado (garantindo a ordem do txt)
    }
  
    return null;
  }
  
  function saveFilePathsToTXT(filePaths) {
    try {
      var txtPath =
        "C:/Program Files (x86)/Common Files/Adobe/CEP/extensions/boredpanda/arquivos.txt"; // Caminho fixo
      var txtFile = new File(txtPath);
  
      if (!txtFile.open("w")) {
        // Abre o arquivo no modo escrita
        return "‚ùå Erro ao abrir o arquivo TXT para escrita.";
      }
  
      txtFile.write(filePaths.replace(/\n/g, "\r")); // Escreve os caminhos no arquivo
      txtFile.close();
  
      return "‚úÖ Caminhos salvos com sucesso!";
    } catch (e) {
      return "‚ùå Erro inesperado: " + e.toString();
    }
  }
  
  function addTransitionsAbove() {
    try {
      var sequence = app.project.activeSequence;
      if (!sequence) {
        return "‚ùå Nenhuma sequ√™ncia ativa encontrada. Crie uma sequ√™ncia primeiro.";
      }
  
      var videoTracks = sequence.videoTracks;
      var numTracks = videoTracks.numTracks;
  
      // Criar uma trilha de v√≠deo acima da principal, se necess√°rio
      var transitionTrack;
      if (numTracks < 2) {
        sequence.addVideoTrack();
        $.sleep(500); // üî• Delay para garantir que a trilha seja criada
        transitionTrack = sequence.videoTracks[1];
      } else {
        transitionTrack = videoTracks[1];
      }
  
      var primaryTrack = videoTracks[0]; // Primeira trilha onde est√£o os v√≠deos
      var numClips = primaryTrack.clips.numItems;
  
      if (numClips < 2) {
        return "‚ö†Ô∏è N√£o h√° clipes suficientes para adicionar transi√ß√µes.";
      }
  
      var transitionPath =
        "C:/Users/theel/Videos/premiere_test/transitions/A1.mov";
      var outroPath = "C:/Users/theel/Videos/premiere_test/transitions/outro.mp4";
  
      var transitionFile = new File(transitionPath);
      var outroFile = new File(outroPath);
  
      if (!transitionFile.exists) {
        return "‚ùå O arquivo de transi√ß√£o n√£o foi encontrado: " + transitionPath;
      }
      if (!outroFile.exists) {
        return "‚ùå O arquivo 'Outro' n√£o foi encontrado: " + outroPath;
      }
  
      // Importar os arquivos, se necess√°rio
      var transitionItem = findOrImportFile("A1.mov", transitionFile);
      var outroItem = findOrImportFile("outro.mp4", outroFile);
  
      if (!transitionItem || !outroItem) {
        return "‚ùå Erro ao importar os arquivos.";
      }
  
      var currentTime = 0;
  
      // Adicionar transi√ß√µes entre os v√≠deos
      for (var i = 0; i < numClips - 1; i++) {
        var clip = primaryTrack.clips[i];
        var nextClip = primaryTrack.clips[i + 1];
  
        if (clip && nextClip) {
          var clipEnd = clip.end.seconds;
          var transitionDuration = transitionItem.getOutPoint().seconds;
  
          // Adiciona a transi√ß√£o na trilha acima, no meio entre os v√≠deos
          transitionTrack.insertClip(
            transitionItem,
            clipEnd - transitionDuration / 2
          );
        }
      }
  
      // üî• Agora adicionamos o "Outro" depois do √∫ltimo v√≠deo
      var lastClip = primaryTrack.clips[numClips - 1];
      if (lastClip) {
        var outroPosition = lastClip.end.seconds;
        transitionTrack.insertClip(outroItem, outroPosition);
      }
  
      return "‚úÖ Transi√ß√µes adicionadas e 'Outro' colocado no final.";
    } catch (e) {
      return "Erro inesperado: " + e.toString();
    }
  }
  
  // üî• Fun√ß√£o para encontrar ou importar um arquivo
  function findOrImportFile(fileName, fileObject) {
    var item = findItemInProject(fileName);
    if (!item) {
      app.project.importFiles(
        [fileObject.fsName],
        true,
        app.project.rootItem,
        false
      );
      $.sleep(500); // üî• Delay para garantir que a importa√ß√£o foi conclu√≠da
      item = findItemInProject(fileName);
    }
    return item;
  }
  
  // Fun√ß√£o auxiliar para encontrar um arquivo no projeto
  function findItemInProject(name) {
    var rootItem = app.project.rootItem;
    var numItems = rootItem.children.numItems;
  
    for (var i = 0; i < numItems; i++) {
      var item = rootItem.children[i];
      if (item && item.name === name) {
        return item;
      }
    }
    return null;
  }
  
  function addSubscribeAndLike() {
    try {
      var sequence = app.project.activeSequence;
      if (!sequence) {
        return "‚ùå Nenhuma sequ√™ncia ativa encontrada. Crie uma sequ√™ncia primeiro.";
      }
  
      var videoTracks = sequence.videoTracks;
      var numTracks = videoTracks.numTracks;
  
      // Criar uma nova trilha de v√≠deo acima da principal, se necess√°rio
      var overlayTrack;
      if (numTracks < 2) {
        sequence.addVideoTrack();
        $.sleep(500); // üî• Pequeno delay para garantir que a trilha seja criada
        overlayTrack = sequence.videoTracks[1];
      } else {
        overlayTrack = videoTracks[1];
      }
  
      var primaryTrack = videoTracks[0];
      var numClips = primaryTrack.clips.numItems;
  
      if (numClips < 2) {
        return "‚ö†Ô∏è N√£o h√° clipes suficientes para adicionar overlays.";
      }
  
      var subscribePath =
        "C:/Users/theel/Videos/premiere_test/like sub/Subscribe.mov";
      var likePath = "C:/Users/theel/Videos/premiere_test/like sub/Like.mov";
  
      var subscribeFile = new File(subscribePath);
      var likeFile = new File(likePath);
  
      if (!subscribeFile.exists || !likeFile.exists) {
        return "‚ùå Arquivos de overlay n√£o encontrados.";
      }
  
      // üî• Agora importamos primeiro e s√≥ depois tentamos usar os arquivos
      var subscribeItem = findOrImportFile("Subscribe.mov", subscribeFile);
      var likeItem = findOrImportFile("Like.mov", likeFile);
  
      if (!subscribeItem || !likeItem) {
        return "‚ùå Erro ao importar os arquivos de overlay.";
      }
  
      var overlayIndex = 0;
  
      // Alternar entre Subscribe e Like nos v√≠deos certos
      for (var i = 0; i < numClips; i += 2) {
        var clip = primaryTrack.clips[i];
  
        if (clip) {
          var clipMiddle = clip.start.seconds + clip.duration.seconds * 0.75;
  
          // Alternar entre Subscribe e Like
          var overlayItem = overlayIndex % 2 === 0 ? subscribeItem : likeItem;
  
          try {
            overlayTrack.insertClip(overlayItem, clipMiddle);
          } catch (e) {
            return "‚ùå Erro ao adicionar overlay na timeline.";
          }
  
          overlayIndex++;
        }
      }
  
      return "‚úÖ Overlays 'Inscreva-se' e 'Like' adicionados na trilha superior.";
    } catch (e) {
      return "Erro inesperado: " + e.toString();
    }
  }
  
  // üî• Fun√ß√£o melhorada para encontrar ou importar um arquivo corretamente
  function findOrImportFile(fileName, fileObject) {
    var item = findItemInProject(fileName);
    if (!item) {
      app.project.importFiles(
        [fileObject.fsName],
        true,
        app.project.rootItem,
        false
      );
      $.sleep(500); // üî• Pequeno delay para garantir que a importa√ß√£o foi conclu√≠da
      item = findItemInProject(fileName);
    }
    return item;
  }
  
  // Fun√ß√£o auxiliar para encontrar um arquivo pelo nome no projeto
  function findItemInProject(name) {
    var rootItem = app.project.rootItem;
    var numItems = rootItem.children.numItems;
  
    for (var i = 0; i < numItems; i++) {
      var item = rootItem.children[i];
      if (item && item.name === name) {
        return item;
      }
    }
    return null;
  }
  
  function addWatermark() {
    try {
      var sequence = app.project.activeSequence;
      if (!sequence) return "‚ùå Nenhuma sequ√™ncia ativa.";
  
      var videoTracks = sequence.videoTracks;
      var numTracks = videoTracks.numTracks;
  
      // üî• Usar a Track 3 se existir, caso contr√°rio, usar a √∫ltima dispon√≠vel
      var watermarkTrack;
      if (numTracks >= 3) {
        watermarkTrack = videoTracks[2]; // Track 3 (√≠ndice 2)
      } else {
        watermarkTrack = videoTracks[numTracks - 1]; // √öltima trilha dispon√≠vel
      }
  
      var primaryTrack = videoTracks[0]; // Primeira trilha onde est√£o os v√≠deos
      var numClips = primaryTrack.clips.numItems;
  
      if (numClips < 1) {
        return "‚ö†Ô∏è N√£o h√° clipes suficientes para adicionar a Watermark.";
      }
  
      var watermarkPath =
        "C:/Users/theel/Videos/premiere_test/watermark/watermark.png";
      var watermarkFile = new File(watermarkPath);
  
      if (!watermarkFile.exists) {
        return "‚ùå Arquivo da Watermark n√£o encontrado.";
      }
  
      // üî• Importar a Watermark se ainda n√£o estiver no projeto
      var watermarkItem = findOrImportFile("watermark.png", watermarkFile);
  
      if (!watermarkItem) {
        return "‚ùå Erro ao importar a Watermark.";
      }
  
      // üî• Encontrar o primeiro e o √∫ltimo clipe da timeline
      var firstClip = primaryTrack.clips[0]; // Primeiro clipe
      var lastClip = primaryTrack.clips[numClips - 1]; // √öltimo clipe (provavelmente o "Outro")
  
      if (!firstClip || !lastClip) {
        return "‚ùå Erro ao identificar in√≠cio ou fim da Watermark.";
      }
  
      var startPosition = firstClip.start.seconds; // Come√ßo do primeiro v√≠deo
      var endPosition = lastClip.end.seconds; // üî• Pegamos o fim EXATO do √∫ltimo clipe
  
      // üî• Inserir a Watermark na trilha 3 ou na √∫ltima trilha dispon√≠vel
      var watermarkClip = watermarkTrack.insertClip(watermarkItem, startPosition);
      if (!watermarkClip) {
        return "‚ùå Erro ao inserir a Watermark na timeline.";
      }
  
      // üî• Ajustar a dura√ß√£o da Watermark manualmente
      watermarkClip.end = endPosition; // üî• Ajusta para cobrir todo o v√≠deo
  
      return "‚úÖ Watermark adicionada na Track 3, cobrindo todo o v√≠deo!";
    } catch (e) {
      return "Erro inesperado: " + e.toString();
    }
  }
  
  // üî• Fun√ß√£o para encontrar ou importar um arquivo corretamente
  function findOrImportFile(fileName, fileObject) {
    var item = findItemInProject(fileName);
    if (!item) {
      app.project.importFiles(
        [fileObject.fsName],
        true,
        app.project.rootItem,
        false
      );
      $.sleep(500); // üî• Pequeno delay para garantir que a importa√ß√£o foi conclu√≠da
      item = findItemInProject(fileName);
    }
    return item;
  }
  
  // üî• Fun√ß√£o auxiliar para encontrar um arquivo no projeto
  function findItemInProject(name) {
    var rootItem = app.project.rootItem;
    var numItems = rootItem.children.numItems;
  
    for (var i = 0; i < numItems; i++) {
      var item = rootItem.children[i];
      if (item && item.name === name) {
        return item;
      }
    }
    return null;
  }
  